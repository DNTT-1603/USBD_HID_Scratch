# USBD_HID_Scratch (STM32L476, USB OTG FS device)

This repo is a scratchpad project for bringing up USB device mode on an STM32L476 (USB OTG FS), with a tiny custom USB device stack layered on top of the STM32 USB OTG FS registers.

At the moment, it mainly demonstrates:
- A polled (non-IRQ-driven) USB OTG FS “driver” that reads `GINTSTS` and the RxFIFO.
- A minimal control endpoint (EP0) flow that recognizes a `GET_DESCRIPTOR` request and returns a Device Descriptor.
- SWO/ITM logging to see enumeration/requests.

## Target / toolchain
- MCU: `STM32L476RGTX` (see `STM32L476RGTX_FLASH.ld`)
- USB pins: `PA11` (DM), `PA12` (DP)
- Project format: STM32CubeIDE/CubeMX generated project (artifact name is `TEst`)

## Build

### STM32CubeIDE
1. Open the project in STM32CubeIDE.
2. Build the `Debug` configuration.
3. Flash via ST-LINK.

### Command line (Makefile generated by CubeIDE)
If you have `arm-none-eabi-gcc` in PATH:
- `make -C Debug`

## Runtime behavior (what you should see)
- When you plug the board into a USB host, the device should at least answer the host’s initial **Device Descriptor** request.
- If SWO is enabled, logs come out via ITM (see “Logging”).

## Repo layout
- `Core/Src/main.c`: firmware entry point; sets up HAL clocks/GPIO/USB PCD and runs the polling loop.
- `Core/Src/USBT_Src/usbd_driver.c`: low-level USB OTG FS register driver (polls `GINTSTS`, reads RxFIFO, writes TxFIFO).
- `Core/Src/USBT_Src/usbd_framwork.c`: minimal “USB device framework” (EP0 control state machine + request dispatch).
- `Core/Inc/USBT_Inc/usbd_standards.h`: USB enums/structs (requests, descriptors, state machine stages).
- `Core/Inc/USBT_Inc/usbd_descriptors.h`: currently only a `device_descriptor`.
- `Core/Src/logger.c`: SWO/ITM logging implementation.
- `images/`: notes/figures used for understanding USB transactions.

There are also additional CubeIDE projects in `TEst/` and `TEstprj02/` which are mostly baseline/generated variants.

## Code flow (end-to-end)

### 1) Startup and main loop
`Core/Src/main.c` does:
1. `HAL_Init()`
2. `SystemClock_Config()`
3. `MX_GPIO_Init()`
4. `MX_USB_OTG_FS_PCD_Init()`
   - This is CubeMX/HAL-generated and sets up the USB OTG FS peripheral.
5. Prepares an 8-word FIFO/out buffer for EP0 SETUP packets:
   - `usb_device.prt_out_buffer = buffer;`
6. Calls `usbd_initialize(&usb_device);`
7. Runs forever:
   - `while (1) { usbd_poll(); }`

### 2) Framework init
`Core/Src/USBT_Src/usbd_framwork.c:usbd_initialize()`:
- Stores the global `UsbDevice *` handle.
- Calls `usbd_driver.initialize_usb_core_external()` (enables a couple of endpoint interrupt masks).
- Calls `usbd_driver.connect()` (clears “soft disconnect” so the host can enumerate).

Note: `usbd_driver.initialize_core()` / `usbd_driver.initialize_gpio_pins()` exist, but the current project relies on the CubeMX/HAL init (`MX_USB_OTG_FS_PCD_Init()` + `HAL_PCD_MspInit()`) for clocks/pins.

### 3) Polling the USB core
`usbd_poll()` just calls into the driver:
- `Core/Src/USBT_Src/usbd_framwork.c:usbd_poll()` → `usbd_driver.poll()`
- `usbd_driver.poll` is `Core/Src/USBT_Src/usbd_driver.c:GINTSTS_handler()`

`GINTSTS_handler()` reads `USB_OTG_FS_GLOBAL->GINTSTS` and (currently) handles **one** event per poll due to an `if/else if` chain.

Handled events:
- **USB reset** (`USBRST`)
  - `usbrts_handle()` deconfigures endpoints, flushes FIFOs, then calls `usb_events.on_usb_reset_received()`.
  - Framework callback `usb_reset_received_handler()` resets the software state and sets address to `0`.

- **Enumeration done** (`ENUMDNE`)
  - `enumeration_done_handle()` calls `configure_endpoint0(8)`.

- **RxFIFO not empty** (`RXFLVL`)
  - `rxflvl_handle()` reads `GRXSTSP` to learn `EPNUM`, `BCNT`, and `PKTSTS`.
  - For a **SETUP packet** (`PKTSTS == 0x06`), it calls `usb_events.on_setup_data_received(ep, bcnt)`.

After servicing the event, the driver calls `usb_events.on_usb_polled()` every time. That callback is what advances the EP0 control-transfer state machine.

### 4) SETUP packet handling and request dispatch
Framework callback:
- `usb_setup_data_received_handler(endpoint_number, bcnt)`:
  1. `usbd_driver.read_packet(usb_device->prt_out_buffer, bcnt)` copies the SETUP data out of the RxFIFO.
  2. Logs the raw 8 bytes.
  3. Calls `process_request()`.

`process_request()` parses `UsbRequest` (the standard 8-byte setup packet) and dispatches:
- Standard + Device recipient → `process_standard_device_request()`

Currently implemented path:
- `bRequest == USB_STANDARD_GET_DESCRIPTOR` (0x06)
  - Determines descriptor type from `(wValue >> 8)`.
  - For `USB_DESCRIPTOR_TYPE_DEVICE`:
    - Sets `usb_device->prt_in_buffer = &device_descriptor`.
    - Sets `usb_device->in_data_size = wLength`.
    - Sets `usb_device->control_transfer_stage = USB_CONTROL_STAGE_DATA_IN`.

### 5) Control transfer state machine (EP0)
The framework’s “tick” is:
- `usb_events.on_usb_polled` → `usb_polled_hander()` → `process_control_transfer_state()`

Relevant stage:
- `USB_CONTROL_STAGE_DATA_IN`
  - Chooses `data_size = MIN(in_data_size, device_descriptor.bMaxPacketSize0)`.
  - Calls `usbd_driver.write_packet(0, prt_in_buffer, ...)` to push data into EP0 TxFIFO.
  - Advances internal pointers/sizes.
  - Switches to `USB_CONTROL_STAGE_STATUS_IN_IDLE`.

The intent is “SETUP → DATA IN → STATUS” for a device-to-host control transfer.

## Logging
Logs are printed via `printf()` redirected to SWO/ITM:
- `Core/Src/logger.c` overrides `_write()` and calls `ITM_SendChar()`.

To view logs:
- Run under a debugger that supports SWO.
- Enable SWO/ITM stimulus port 0 in your IDE/debugger.

## Current limitations / TODOs
This is a work-in-progress scratch stack; some behaviors are incomplete:
- Only the **Device Descriptor** path of `GET_DESCRIPTOR` is implemented.
- `SET_ADDRESS` / `SET_CONFIGURATION` are stubbed.
- `IEPINT`/`OEPINT` handling exists (`iepint_handler()` / `oepint_handler()`), but `GINTSTS_handler()` doesn’t currently call them (the `IEPINT`/`OEPINT` branches are placeholders).
- EP0 DATA stage handling is not yet a complete multi-packet control transfer implementation.
- Some APIs use `void const *` for buffers even though they are written to (const-correctness is not finalized).

## Notes
- `images/usb_request_setup_transaction_data.png` is a helpful reference for the SETUP transaction format.

## UsbControlTransferStage explain
  - USB_CONTROL_STAGE_SETUP (…/usb_standards.h:32): “idle”/waiting for the next SETUP packet; you parse the
    8‑byte UsbRequest and decide what comes next (DATA or STATUS).
  - USB_CONTROL_STAGE_DATA_OUT (…/usb_standards.h:33): DATA stage where host → device sends wLength bytes
    (e.g., HID SET_REPORT); after all bytes are received, you finish with STATUS_IN.
  - USB_CONTROL_STAGE_DATA_IN (…/usb_standards.h:34): DATA stage where device → host returns up to wLength
    bytes (e.g., GET_DESCRIPTOR); typically sent in bMaxPacketSize0 chunks.
  - USB_CONTROL_STAGE_DATA_IN_IDLE (…/usb_standards.h:35): internal “wait” state between IN chunks; a packet
    was queued/sent and you’re waiting for the IN transfer-complete interrupt before sending the next chunk
    (see USB_Device_Firmware/Src/usbd_framework.c:146).
  - USB_CONTROL_STAGE_DATA_IN_ZERO (…/usb_standards.h:36): internal “need to send a ZLP” helper; used when
    your last DATA_IN packet was exactly bMaxPacketSize0 (so not a short packet) but you still must signal
    “end of data” → respond to the next IN token with a 0‑byte packet, then move to STATUS_OUT (see
    USB_Device_Firmware/Src/usbd_framework.c:164 and USB_Device_Firmware/Src/usbd_framework.c:220).
  - USB_CONTROL_STAGE_STATUS_OUT (…/usb_standards.h:37): STATUS stage for a control‑read (DATA_IN) transfer:
    host → device sends an OUT zero‑length packet to acknowledge; then you’re done → back to SETUP/IDLE.
  - USB_CONTROL_STAGE_STATUS_IN (…/usb_standards.h:38): STATUS stage for a control‑write (DATA_OUT) or
    no‑data request: device → host sends an IN zero‑length packet; then done → back to SETUP/IDLE (see
    USB_Device_Firmware/Src/usbd_framework.c:185).